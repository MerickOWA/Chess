using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Chess.Model
{
	internal class MoveGenerator
	{
		InternalBoard _board;
		Piece _active;
		Castling _castling;
		Cell _enpassant;
		int _drawClock;
		int _move;

		public MoveGenerator(GameState state)
		{
			_board = new InternalBoard(state.Board);
			_active = state.Active;
			_castling = state.Castling;
			_enpassant = state.Enpassant;
			_drawClock = state.DrawClock;
			_move = state.Move;
		}

		public IBoard Board => _board;
		public Piece Active => _active;
		public Castling Castling => _castling;
		public Cell Enpassant => _enpassant;
		public int DrawClock => _drawClock;
		public int Move => _move;

		public UndoMove MakeMove(Move move)
		{
			var from = (int)move.From;
			var to = (int)move.To;

			//*** Move the piece on the board from the 'from' cell to the 'to' cell
			var capture = _board[move.To];
			var piece = _board[move.From];
			var pieceType = piece & Piece.Type;

			var retval = new UndoMove(move.From, move.To, move.Promotion, capture, _castling, _enpassant, _drawClock);

			if (move.Promotion != Piece.None)
			{
				piece = _active | move.Promotion;
			}

			_board[to] = piece;
			_board[from] = Piece.None;

			//*** Remove captured pawn in enpassant moves
			if (move.To == _enpassant && pieceType == Piece.Pawn)
			{
				_board[(from & 56) | (to & 7)] = Piece.None;
			}

			//*** If we've castled the king, move the corrisponding rook as well
			if (Math.Abs(from - to) == 2 && pieceType == Piece.King)
			{
				var rook = GetCastlingRookCell(move.To);

				_board[(from + to) / 2] = _board[rook];
				_board[rook] = Piece.None;
			}

			//*** Invalidate appropriate castling once the king or rook move
			if (pieceType == Piece.King)
			{
				if (move.From == Cell.e1)
				{
					_castling &= ~Castling.KQ;
				}
				else if (move.From == Cell.e8)
				{
					_castling &= ~Castling.kq;
				}
			}
			else if (pieceType == Piece.Rook)
			{
				if (move.From == Cell.a1)
				{
					_castling &= ~Castling.Q;
				}
				else if (move.From == Cell.h1)
				{
					_castling &= ~Castling.K;
				}
				else if (move.From == Cell.a8)
				{
					_castling &= ~Castling.q;
				}
				else if (move.From == Cell.h8)
				{
					_castling &= ~Castling.k;
				}
			}

			//*** Increment the move count if black just made a move
			if (_active == Piece.Black)
			{
				_move++;
			}

			//*** If the move is a non-capture by a non-pawn piece, then the draw clock is incremented
			//*** otherwise it resets
			if (capture == Piece.None && pieceType != Piece.Pawn)
			{
				_drawClock++;
			}
			else
			{
				_drawClock = 0;
			}

			//*** Update enpassant state if a pawn has made a double move
			if (pieceType == Piece.Pawn && Math.Abs(from - to) == 16)
			{
				_enpassant = (Cell)((from + to) / 2);
			}
			else
			{
				_enpassant = Cell.None;
			}

			//*** Update the active color state
			_active ^= Piece.Color;

			return retval;
		}

		public void UndoMove(UndoMove move)
		{
			var from = (int)move.From;
			var to = (int)move.To;

			var piece = _board[to];

			if (move.Promotion != Piece.None)
			{
				piece = (piece & Piece.Color) | Piece.Pawn;
			}

			var pieceType = piece & Piece.Type;

			_board[from] = piece;
			_board[to] = move.Capture;

			if (move.To == move.Enpassant && pieceType == Piece.Pawn)
			{
				_board[(from & 56) | (to & 7)] = Piece.Pawn | _active;
			}

			if (Math.Abs(from - to) == 2 && pieceType == Piece.King)
			{
				var mid = (from + to) / 2;
				var rook = GetCastlingRookCell(move.To);
				_board[rook] = _board[mid];
				_board[mid] = Piece.None;
			}

			_active ^= Piece.Color;
			_enpassant = move.Enpassant;
			_castling = move.Castling;
			_drawClock = move.DrawClock;
		}

		private static Cell GetCastlingRookCell(Cell kingTo)
		{
			switch (kingTo)
			{
				case Cell.g1: return Cell.h1;
				case Cell.g8: return Cell.h8;
				case Cell.c1: return Cell.a1;
				case Cell.c8: return Cell.a8;
			}

			throw new InvalidOperationException("Invalid castling move");
		}

		public IList<Move> GetMoves()
		{
			var opponent = _active ^ Piece.Color;
			var castling = _castling & (_active == Piece.White ? Castling.KQ : Castling.kq);
			Func<Cell, bool> isOccupied = _board.IsOccupied;

			var kingCell = _board.First(cell => _board[cell] == (Piece.King | _active));

			//*** Generate all movements of opponent pieces which could capture the current player's king
			//*** NOTE: these are not ordinary moves, as the opponent can't "capture" their own pieces
			//***       however, squares which contain an opponents piece are still "protected" from capture by
			//***       the active player's king due to other pieces of the opponent "attacking" the square
			//***       containing their own piece
			//*** NOTE: only pawn "attack" moves are only generated by passing a "fully" occupied board state
			//***       thus generating moves regardless of the actual occupied state of the neighboring cells
			//***       and preventing the cells immediately infront of the pawn from being considered as "attacked"
			var attacks = GetAttacks(kingCell);

			var pins = (
				from dir in Direction.Queen
				let pinnedCell = OccupiedInDirection(kingCell, dir, isOccupied)
				where pinnedCell != Cell.None && (_board[pinnedCell] & Piece.Color) == _active
				let pinnerCell = OccupiedInDirection(pinnedCell, dir, isOccupied)
				where pinnerCell != Cell.None
				let pinner = _board[pinnerCell]
				where (pinner & Piece.Color) == opponent && Direction.CanMove(pinner, dir)
				select new { Cell = pinnedCell, Direction = dir.Abs() })
				.ToDictionary(k => k.Cell, v => v.Direction);

			var attacked = attacks.Select(o => o.To).ToSet();
			Func<Cell, bool> isSafe = cell => !attacked.Contains(cell);
			var checks = attacks.Where(o => o.To == kingCell);

			var checkCount = checks.Count();
			if (checkCount > 1)
			{
				return GetKingOnlyMoves(kingCell, _board.IsOccupied, isSafe).ToList();
			}
			else if (checkCount == 1)
			{
				var check = checks.First();
				var checkPieceType = _board[check.From] & Piece.Type;

				//*** When in check, we can capture the piece, or block the check.
				//*** For pawns & knight checks, only capturing the piece works.
				Func<Move, bool> allowedMove = checkPieceType == Piece.Pawn || checkPieceType == Piece.Knight
					? allowedMove = move => move.To == check.From
					: allowedMove = new LineSegement(check).IsMoveBetween;

				//*** King is always allowed to move
				Func<Move, bool> kingOrAllowedMove = move => move.From == kingCell || allowedMove(move);

				return GetPieceMoves(_board, _active, isSafe, pins)
						.Concat(GetEnpassantMoves(_board, _active, _enpassant))
						.Where(kingOrAllowedMove)
						.ToList();
			}
			else
			{
				return GetPieceMoves(_board, _active, isSafe, pins)
						.Concat(GetCastlingMoves(kingCell, castling, isSafe))
						.Concat(GetEnpassantMoves(_board, _active, _enpassant))
						.ToList();
			}
		}

		private IEnumerable<Move> GetAttacks(Cell kingCell)
		{
			//*** Don't treat the king's position as occupied so that sliding pieces pass through and correctly
			//*** mark cells behind the kind as under "attack" and therefore unsafe as well.  Otherwise, it appears
			//*** as if the king can just back away from them.
			Func<Cell, bool> isOccupied = cell => cell != kingCell && _board.IsOccupied(cell);

			return
				from src in _board
				let piece = _board[src]
				where (piece & Piece.Color) == (_active ^ Piece.Color)
				from dst in CellMoves(src, piece, (piece & Piece.Type) != Piece.Pawn ? isOccupied : _ => true, null)
				select new Move(src, dst);
		}

		private static IEnumerable<Move> GetKingOnlyMoves(Cell src, Func<Cell, bool> isOccupied, Func<Cell, bool> isSafe)
		{
			return
				from dst in KingMoves(src, isOccupied, null)
				where isSafe(dst)
				select new Move(src, dst);
		}

		private static IEnumerable<Move> GetPieceMoves(InternalBoard board, Piece active, Func<Cell, bool> isSafe, IDictionary<Cell,Direction> pins)
		{
			var promotionRank = active == Piece.White ? 0 : 7;

			return
				from src in board
				let piece = board[src]
				where (piece & Piece.Color) == active
				let pieceType = piece & Piece.Type
				from dst in CellMoves(src, piece, board.IsOccupied, pins.GetNullable(src))
				where (board[dst] & Piece.Color) != active && (pieceType != Piece.King || isSafe(dst))
				let move = new Move(src, dst)
				from result in
					pieceType == Piece.Pawn && dst.Rank() == promotionRank ? ApplyPromotion(move) :
					Enumerable.Repeat(move, 1)
				select result;
		}

		private static IEnumerable<Move> ApplyPromotion(Move move)
		{
			yield return move.PromoteTo(Piece.Queen);
			yield return move.PromoteTo(Piece.Rook);
			yield return move.PromoteTo(Piece.Bishop);
			yield return move.PromoteTo(Piece.Knight);
		}

		private static IEnumerable<Move> GetCastlingMoves(Cell from, Castling castling, Func<Cell,bool> isSafe)
		{
			if (isSafe(from))
			{
				var to = from + Direction.LeftLeft;
				if ((castling & Castling.Qq) != Castling.None && isSafe(from + Direction.Left) && isSafe(to))
				{
					yield return new Move(from, to);
				}

				to = from + Direction.RightRight;
				if ((castling & Castling.Kk) != Castling.None && isSafe(from + Direction.Right) && isSafe(to))
				{
					yield return new Move(from, to);
				}
			}
		}

		private static IEnumerable<Move> GetEnpassantMoves(IBoard board, Piece active, Cell to)
		{
			if (to != Cell.None)
			{
				var backward = active == Piece.White ? Direction.Down : Direction.Up;
				var pawn = active | Piece.Pawn;

				var from = to + (backward + Direction.Left);
				if (from != Cell.None && board[from] == pawn)
				{
					yield return new Move(from, to);
				}

				from = to + (backward + Direction.Right);
				if (from != Cell.None && board[from] == pawn)
				{
					yield return new Move(from, to);
				}
			}
		}

		private static IEnumerable<Cell> CellMoves(Cell cell, Piece piece, Func<Cell,bool> isOccupied, Direction? pin)
		{
			switch (piece)
			{
				case Piece.WhitePawn:
					return PawnMoves(cell, isOccupied, pin, Direction.Up, 1);

				case Piece.BlackPawn:
					return PawnMoves(cell, isOccupied, pin, Direction.Down, 6);

				case Piece.WhiteKnight:
				case Piece.BlackKnight:
					return SlidingMoves(cell, Direction.Knight, isOccupied, pin, limited: true);

				case Piece.WhiteBishop:
				case Piece.BlackBishop:
					return SlidingMoves(cell, Direction.Bishop, isOccupied, pin, limited: false);

				case Piece.WhiteRook:
				case Piece.BlackRook:
					return SlidingMoves(cell, Direction.Rook, isOccupied, pin, limited: false);

				case Piece.WhiteQueen:
				case Piece.BlackQueen:
					return SlidingMoves(cell, Direction.Queen, isOccupied, pin, limited: false);

				case Piece.WhiteKing:
				case Piece.BlackKing:
					return KingMoves(cell, isOccupied, pin);

				default:
					throw new InvalidOperationException("Can't generate moves for unknown piece");
			}
		}

		private static IEnumerable<Cell> KingMoves(Cell cell, Func<Cell, bool> isOccupied, Direction? pin)
		{
			return SlidingMoves(cell, Direction.Queen, isOccupied, pin, limited: true);
		}

		private static IEnumerable<Cell> PawnMoves(Cell cell, Func<Cell, bool> isOccupied, Direction? pin, Direction forward, int initalRank)
		{
			var dir = forward;
			var to = cell + dir;
			if (!isOccupied(to) && IsAllowedByPin(pin, dir))
			{
				yield return to;

				to += forward;
				if (cell.Rank() == initalRank && !isOccupied(to))
				{
					yield return to;
				}
			}

			dir = forward + Direction.Left;
			to = cell + dir;
			if (to != Cell.None && isOccupied(to) && IsAllowedByPin(pin, dir))
			{
				yield return to;
			}

			dir = forward + Direction.Right;
			to = cell + dir;
			if (to != Cell.None && isOccupied(to) && IsAllowedByPin(pin, dir))
			{
				yield return to;
			}
		}

		private static IEnumerable<Cell> SlidingMoves(Cell from, IEnumerable<Direction> directions, Func<Cell, bool> isOccupied, Direction? pin, bool limited)
		{
			//*** Generate moves in every direction
			foreach (var direction in directions)
			{
				//*** If we're pinned, the piece can only move along the direction of the pin (either toward or away)
				if (!IsAllowedByPin(pin, direction)) continue;

				var to = from + direction;

				while (to != Cell.None)
				{
					if (!isOccupied(to))
					{
						//*** Allowed to move to a cell if there is no piece there
						yield return to;
					}
					else
					{
						//*** Allowed to capture an opponent's piece
						yield return to;

						//*** Stop moving in this direction once we've hit another piece
						break;
					}

					if (limited)
					{
						//*** Limited movement pieces can only move in a given direction once
						break;
					}

					//*** Move to the next cell along the "direction"
					to = to + direction;
				}
			}
		}

		private static bool IsAllowedByPin(Direction? pin, Direction direction)
		{
			return pin == null || direction.Abs() == pin.Value;
		}

		private Cell OccupiedInDirection(Cell from, Direction direction, Func<Cell,bool> isOccupied)
		{
			var cell = from;

			do
			{
				cell += direction;
			} while (cell != Cell.None && !isOccupied(cell));

			return cell;
		}

		private struct InternalBoard : IBoard, IEnumerable<Cell>
		{
			private Piece[] _pieces;

			public InternalBoard(Board board)
			{
				_pieces = board.ToArray();
			}

			public Piece this[int cell]
			{
				get { return _pieces[cell]; }
				set { _pieces[cell] = value; }
			}

			public Piece this[Cell cell]
			{
				get { return _pieces[(int)cell]; }
				set { _pieces[(int)cell] = value; }
			}

			public bool IsOccupied(Cell cell)
			{
				return this[cell] != Piece.None;
			}

			public IEnumerator<Cell> GetEnumerator()
			{
				for(Cell i = Cell.a1; i <= Cell.h8; i++)
				{
					yield return i;
				}
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return ((IEnumerable<Cell>)this).GetEnumerator();
			}
		}

		private struct LineSegement
		{
			private int a;
			private int b;
			private int c;
			private int maxFile;
			private int maxRank;
			private int minFile;
			private int minRank;

			public LineSegement(Move m)
			{
				var from = m.From;
				var to = m.To;
				var fromFile = from.File();
				var fromRank = from.Rank();
				var toFile = to.File();
				var toRank = to.Rank();

				minFile = Math.Min(fromFile, toFile);
				maxFile = Math.Max(fromFile, toFile);
				minRank = Math.Min(fromRank, toRank);
				maxRank = Math.Max(fromRank, toRank);

				a = (toFile - fromFile);
				b = (toRank - fromRank);
				c = fromRank * a - fromFile * b;
			}

			public bool IsMoveBetween(Move m)
			{
				var to = m.To;
				return to.File() >= minFile && to.File() <= maxFile
					&& to.Rank() >= minRank && to.Rank() <= maxRank
					&& to.Rank() * a - to.File() * b == c;
			}
		}
	}
}
